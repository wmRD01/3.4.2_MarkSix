{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/Hasher.ts"],"names":["Hasher","BufferedBlockAlgorithm","constructor","props","_props","blockSize","_blockSize","reset","data","undefined","nBytes","call","_doReset","update","messageUpdate","_append","_process","finalize","_doFinalize","Error"],"mappings":";;;sDAOaA,M;;;;;;;;;;;;;;;;;;;;;;;;AAPLC,MAAAA,sB,iBAAAA,sB;;;;;;;wBAOKD,M,GAAN,MAAMA,MAAN;AAAA;AAAA,4DAA4C;AAI1CE,QAAAA,WAAW,CAACC,KAAD,EAA8B;AAC9C,gBAAMA,KAAN;;AAD8C;;AAAA,8CAFjB,MAAI,EAEa;;AAE9C,eAAKC,MAAL,GAAcD,KAAd;;AACA,cAAGA,KAAK,IAAI,OAAOA,KAAK,CAACE,SAAb,KAA2B,QAAvC,EAAgD;AAC9C,iBAAKC,UAAL,GAAkBH,KAAK,CAACE,SAAxB;AACD;;AACD,eAAKE,KAAL,CAAWJ,KAAK,GAAGA,KAAK,CAACK,IAAT,GAAgBC,SAAhC,EAA2CN,KAAK,GAAGA,KAAK,CAACO,MAAT,GAAkBD,SAAlE;AACD;;AAEmB,YAATJ,SAAS,GAAE;AACpB,iBAAO,KAAKC,UAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACSC,QAAAA,KAAK,CAACC,IAAD,EAAqBE,MAArB,EAAqC;AAC/C;AACA,gBAAMH,KAAN,CAAYI,IAAZ,CAAiB,IAAjB,EAAuBH,IAAvB,EAA6BE,MAA7B,EAF+C,CAG/C;;AACA,eAAKE,QAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACSC,QAAAA,MAAM,CAACC,aAAD,EAAmC;AAC9C,eAAKC,OAAL,CAAaD,aAAb;;AACA,eAAKE,QAAL;;AACA,iBAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACSC,QAAAA,QAAQ,CAACH,aAAD,EAAoC;AACjD;AACA,cAAIA,aAAJ,EAAmB;AACjB,iBAAKC,OAAL,CAAaD,aAAb;AACD,WAJgD,CAMjD;;;AACA,iBAAO,KAAKI,WAAL,EAAP;AACD;AAED;AACF;AACA;;;AACYN,QAAAA,QAAQ,GAAS;AACzB,gBAAM,IAAIO,KAAJ,CAAU,iBAAV,CAAN;AACD;AAED;AACF;AACA;;;AACYD,QAAAA,WAAW,GAAgB;AACnC,gBAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AA9EgD,O","sourcesContent":["import {BufferedBlockAlgorithm, BufferedBlockAlgorithmProps} from \"./BufferedBlockAlgorithm\";\nimport type {Word32Array} from \"../Word32Array\";\n\nexport interface HasherProps extends BufferedBlockAlgorithmProps {\n  blockSize: number;\n}\n\nexport class Hasher extends BufferedBlockAlgorithm {\n  protected _props?: Partial<HasherProps>;\n  protected _blockSize: number = 512/32;\n  \n  public constructor(props?: Partial<HasherProps>){\n    super(props);\n    this._props = props;\n    if(props && typeof props.blockSize === \"number\"){\n      this._blockSize = props.blockSize;\n    }\n    this.reset(props ? props.data : undefined, props ? props.nBytes : undefined);\n  }\n  \n  public get blockSize(){\n    return this._blockSize;\n  }\n  \n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *   hasher.reset();\n   */\n  public reset(data?: Word32Array, nBytes?: number){\n    // Reset data buffer\n    super.reset.call(this, data, nBytes);\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n  \n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {Word32Array|string} messageUpdate The message to append.\n   * @return {Hasher} This hasher.\n   * @example\n   *   hasher.update('message');\n   *   hasher.update(wordArray);\n   */\n  public update(messageUpdate: Word32Array|string){\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  \n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {Word32Array|string?} messageUpdate (Optional) A final message update.\n   * @return {Word32Array} The hash.\n   * @example\n   *   var hash = hasher.finalize();\n   *   var hash = hasher.finalize('message');\n   *   var hash = hasher.finalize(wordArray);\n   */\n  public finalize(messageUpdate?: Word32Array|string){\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  \n    // Perform concrete-hasher logic\n    return this._doFinalize();\n  }\n  \n  /**\n   * @abstract\n   */\n  protected _doReset(): void {\n    throw new Error(\"Not implemented\");\n  }\n  \n  /**\n   * @abstract\n   */\n  protected _doFinalize(): Word32Array {\n    throw new Error(\"Not implemented\");\n  }\n}\n"]}
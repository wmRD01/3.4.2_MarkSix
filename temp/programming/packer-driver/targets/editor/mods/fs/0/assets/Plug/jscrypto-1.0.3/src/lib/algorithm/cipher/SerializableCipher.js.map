{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/SerializableCipher.ts"],"names":["parseCipherText","cipherTextParams","formatter","parse","OpenSSLFormatter","CipherParams","SerializableCipher","encrypt","Cipher","message","key","props","encryptor","createEncryptor","cipherText","finalize","iv","Algorithm","mode","padding","blockSize","decrypt","cipherParams","decryptor","createDecryptor","cipherParamsObj"],"mappings":";;;;;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAASA,eAAT,CAAyBC,gBAAzB,EAAgEC,SAAhE,EAAqF;AAC1F,QAAG,OAAOD,gBAAP,KAA4B,QAA/B,EAAwC;AACtC,aAAOC,SAAS,CAACC,KAAV,CAAgBF,gBAAhB,CAAP;AACD;;AACD,WAAOA,gBAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BALeD,e;;;;;;;;AAlCRI,MAAAA,gB,iBAAAA,gB;;AAGAC,MAAAA,Y,iBAAAA,Y;;;;;;;oCAsCKC,kB,GAAuD;AAClE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,QAAAA,OAAO,CACLC,MADK,EAELC,OAFK,EAGLC,GAHK,EAILC,KAJK,EAKN;AACC,gBAAMC,SAAS,GAAGJ,MAAM,CAACK,eAAP,CAAuBH,GAAvB,EAA4BC,KAA5B,CAAlB;AACA,gBAAMG,UAAU,GAAGF,SAAS,CAACG,QAAV,CAAmBN,OAAnB,CAAnB;AAEA,iBAAO;AAAA;AAAA,4CAAiB;AACtBK,YAAAA,UADsB;AAEtBJ,YAAAA,GAFsB;AAGtBM,YAAAA,EAAE,EAAEJ,SAAS,CAACI,EAHQ;AAItBC,YAAAA,SAAS,EAAET,MAJW;AAKtBU,YAAAA,IAAI,EAAGN,SAAD,CAA2BM,IALX;AAMtBC,YAAAA,OAAO,EAAGP,SAAD,CAA2BO,OANd;AAOtBC,YAAAA,SAAS,EAAER,SAAS,CAACQ,SAPC;AAQtBlB,YAAAA,SAAS,EAAE,CAAAS,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAET,SAAP;AAAA;AAAA;AARW,WAAjB,CAAP;AAUD,SAhCiE;;AAkClE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEmB,QAAAA,OAAO,CACLb,MADK,EAELc,YAFK,EAGLZ,GAHK,EAILC,KAJK,EAKN;AACC,gBAAMY,SAAS,GAAGf,MAAM,CAACgB,eAAP,CAAuBd,GAAvB,EAA4BC,KAA5B,CAAlB;AACA,gBAAMc,eAAe,GAAGzB,eAAe,CAACsB,YAAD,EAAe,CAAAX,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAET,SAAP;AAAA;AAAA,mDAAf,CAAvC;AACA,iBAAOqB,SAAS,CAACR,QAAV,CAAmBU,eAAe,CAACX,UAAhB,IAA8B,EAAjD,CAAP;AACD;;AAvDiE,O","sourcesContent":["import type {Formatter} from \"./formatter/type\";\nimport {OpenSSLFormatter} from \"./formatter/OpenSSLFormatter\";\nimport type {Word32Array} from \"../../Word32Array\";\nimport type {BlockCipher, BlockCipherProps} from \"./BlockCipher\";\nimport {CipherParams} from \"./CipherParams\";\nimport {Cipher as BaseCipher} from \"./Cipher\";\n\nexport interface SerializableCipherProps extends BlockCipherProps {\n  formatter: Formatter;\n}\n\nexport interface ISerializableCipher<K extends Word32Array|string> {\n  encrypt: (\n    cipher: typeof BaseCipher,\n    message: Word32Array|string,\n    key: K,\n    props?: Partial<SerializableCipherProps>,\n  ) => CipherParams;\n  decrypt: (\n    cipher: typeof BaseCipher,\n    cipherParams: CipherParams|string,\n    key: K,\n    props?: Partial<SerializableCipherProps>,\n  ) => Word32Array;\n}\n\n/**\n * Converts serialized ciphertext to CipherParams,\n * else assumed CipherParams already and returns ciphertext unchanged.\n * @param {CipherParams|string} cipherTextParams The ciphertext.\n * @param {Formatter} formatter The formatting strategy to use to parse serialized ciphertext.\n * @return {CipherParams} The un-serialized ciphertext.\n * @example\n *   var ciphertextParams = SerializableCipher.parse(ciphertextStringOrParams, format);\n */\nexport function parseCipherText(cipherTextParams: CipherParams|string, formatter: Formatter){\n  if(typeof cipherTextParams === \"string\"){\n    return formatter.parse(cipherTextParams);\n  }\n  return cipherTextParams;\n}\n\nexport const SerializableCipher: ISerializableCipher<Word32Array> = {\n  /**\n   * Encrypts a message.\n   *\n   * @param {typeof Cipher} Cipher The cipher algorithm to use.\n   * @param {Word32Array|string} message The message to encrypt.\n   * @param {Word32Array} key The key.\n   * @param {Partial<SerializableCipherProps>?} props (Optional) The configuration options to use for this operation.\n   * @return {CipherParams} A cipher params object.\n   * @example\n   *   var ciphertextParams = SerializableCipher.encrypt(AES, message, key);\n   *   var ciphertextParams = SerializableCipher.encrypt(AES, message, key, { iv: iv });\n   */\n  encrypt(\n    Cipher: typeof BaseCipher,\n    message: Word32Array|string,\n    key: Word32Array,\n    props?: Partial<SerializableCipherProps>,\n  ){\n    const encryptor = Cipher.createEncryptor(key, props);\n    const cipherText = encryptor.finalize(message);\n    \n    return new CipherParams({\n      cipherText,\n      key,\n      iv: encryptor.iv,\n      Algorithm: Cipher,\n      mode: (encryptor as BlockCipher).mode,\n      padding: (encryptor as BlockCipher).padding,\n      blockSize: encryptor.blockSize,\n      formatter: props?.formatter || OpenSSLFormatter,\n    });\n  },\n  \n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {typeof Cipher} Cipher The cipher algorithm to use.\n   * @param {CipherParams|string} cipherParams The ciphertext to decrypt.\n   * @param {Word32Array} key The key.\n   * @param {Partial<SerializableCipherProps>} props (Optional) The configuration options to use for this operation.\n   * @return {Word32Array} The plaintext.\n   * @example\n   *     var plaintext = SerializableCipher.decrypt(AES, formattedCiphertext, key, { iv: iv, format: OpenSSLFormatter });\n   *     var plaintext = SerializableCipher.decrypt(AES, ciphertextParams, key, { iv: iv, format: OpenSSLFormatter });\n   */\n  decrypt(\n    Cipher: typeof BaseCipher,\n    cipherParams: CipherParams|string,\n    key: Word32Array,\n    props?: Partial<SerializableCipherProps>,\n  ){\n    const decryptor = Cipher.createDecryptor(key, props);\n    const cipherParamsObj = parseCipherText(cipherParams, props?.formatter || OpenSSLFormatter);\n    return decryptor.finalize(cipherParamsObj.cipherText || \"\");\n  }\n}\n"]}
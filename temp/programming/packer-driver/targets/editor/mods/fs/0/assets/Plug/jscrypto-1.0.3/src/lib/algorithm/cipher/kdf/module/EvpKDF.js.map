{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/kdf/module/EvpKDF.ts"],"names":["EvpKDF","MD5","Word32Array","BaseKDFModule","constructor","props","_keySize","keySize","_Hasher","Hasher","_iterations","iterations","compute","password","salt","block","hasher","derivedKey","derivedKeyWords","words","length","update","finalize","reset","i","concat","nSigBytes","getKey"],"mappings":";;;+DAgBaA,M;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAfLC,MAAAA,G,iBAAAA,G;;AACAC,MAAAA,W,iBAAAA,W;;AACAC,MAAAA,a,iBAAAA,a;;;;;;;AAKR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;wBACaH,M,GAAN,MAAMA,MAAN;AAAA;AAAA,0CAAgD;AAK9CI,QAAAA,WAAW,CAACC,KAAD,EAA+B;AAC/C,gBAAMA,KAAN;;AAD+C,4CAJpB,MAAI,EAIgB;;AAAA;AAAA;AAAA;;AAAA,+CAFjB,CAEiB;;AAG/C,cAAGA,KAAH,EAAS;AACP,iBAAKC,QAAL,GAAgB,OAAOD,KAAK,CAACE,OAAb,KAAyB,WAAzB,GAAuCF,KAAK,CAACE,OAA7C,GAAuD,KAAKD,QAA5E;AACA,iBAAKE,OAAL,GAAe,OAAOH,KAAK,CAACI,MAAb,KAAwB,WAAxB,GAAsCJ,KAAK,CAACI,MAA5C,GAAqD,KAAKD,OAAzE;AACA,iBAAKE,WAAL,GAAmB,OAAOL,KAAK,CAACM,UAAb,KAA4B,WAA5B,GAA0CN,KAAK,CAACM,UAAhD,GAA6D,KAAKD,WAArF;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACSE,QAAAA,OAAO,CAACC,QAAD,EAA+BC,IAA/B,EAAwD;AACpE,cAAIC,KAAJ,CADoE,CAGpE;;AACA,gBAAMC,MAAM,GAAG,IAAI,KAAKR,OAAT,EAAf,CAJoE,CAMpE;;AACA,gBAAMS,UAAU,GAAG;AAAA;AAAA,2CAAnB,CAPoE,CASpE;;AACA,gBAAMC,eAAe,GAAGD,UAAU,CAACE,KAAnC;AACA,gBAAMZ,OAAO,GAAG,KAAKD,QAArB;AACA,gBAAMK,UAAU,GAAG,KAAKD,WAAxB,CAZoE,CAcpE;;AACA,iBAAOQ,eAAe,CAACE,MAAhB,GAAyBb,OAAhC,EAAyC;AACvC,gBAAIQ,KAAJ,EAAW;AACTC,cAAAA,MAAM,CAACK,MAAP,CAAcN,KAAd;AACD;;AACDA,YAAAA,KAAK,GAAGC,MAAM,CAACK,MAAP,CAAcR,QAAd,EAAwBS,QAAxB,CAAiCR,IAAjC,CAAR;AACAE,YAAAA,MAAM,CAACO,KAAP,GALuC,CAOvC;;AACA,iBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,UAApB,EAAgCa,CAAC,EAAjC,EAAqC;AACnCT,cAAAA,KAAK,GAAGC,MAAM,CAACM,QAAP,CAAgBP,KAAhB,CAAR;AACAC,cAAAA,MAAM,CAACO,KAAP;AACD;;AAEDN,YAAAA,UAAU,CAACQ,MAAX,CAAkBV,KAAlB;AACD;;AACDE,UAAAA,UAAU,CAACS,SAAX,GAAuBnB,OAAO,GAAG,CAAjC;AAEA,iBAAOU,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,eAANU,MAAM,CAACd,QAAD,EAA+BC,IAA/B,EAAyDT,KAAzD,EAAsF;AACxG,iBAAO,IAAIL,MAAJ,CAAWK,KAAX,EAAkBO,OAAlB,CAA0BC,QAA1B,EAAoCC,IAApC,CAAP;AACD;;AA5EoD,O","sourcesContent":["import type {Hasher} from \"../../../Hasher\";\nimport {MD5} from \"../../../../../MD5\";\nimport {Word32Array} from \"../../../../Word32Array\";\nimport {BaseKDFModule, BaseKDFModuleProps} from \"../type\";\n\nexport interface EvpKDFProps extends BaseKDFModuleProps {\n}\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * https://www.openssl.org/docs/man1.1.1/man3/EVP_BytesToKey.html\n *\n * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n * @property {number} iterations The number of iterations to perform. Default: 1\n */\nexport class EvpKDF extends BaseKDFModule<EvpKDFProps> {\n  protected _keySize: number = 128/32;\n  protected _Hasher: typeof Hasher = MD5;\n  protected _iterations: number = 1;\n  \n  public constructor(props?: Partial<EvpKDFProps>) {\n    super(props);\n    \n    if(props){\n      this._keySize = typeof props.keySize !== \"undefined\" ? props.keySize : this._keySize;\n      this._Hasher = typeof props.Hasher !== \"undefined\" ? props.Hasher : this._Hasher;\n      this._iterations = typeof props.iterations !== \"undefined\" ? props.iterations : this._iterations;\n    }\n  }\n  \n  /**\n   * Derives a key from a password.\n   *\n   * @param {Word32Array|string} password The password.\n   * @param {Word32Array|string} salt A salt.\n   * @return {Word32Array} The derived key.\n   * @example\n   *   var kdf = new EvpKDF();\n   *   var key = kdf.compute(password, salt);\n   */\n  public compute(password: Word32Array|string, salt: Word32Array|string){\n    let block: Word32Array|undefined;\n  \n    // Init hasher\n    const hasher = new this._Hasher();\n  \n    // Initial values\n    const derivedKey = new Word32Array();\n  \n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const keySize = this._keySize;\n    const iterations = this._iterations;\n  \n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n    \n      // Iterations\n      for (let i = 1; i < iterations; i++) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n    \n      derivedKey.concat(block);\n    }\n    derivedKey.nSigBytes = keySize * 4;\n  \n    return derivedKey;\n  }\n  \n  /**\n   * Derives a key from a password.\n   *\n   * @param {Word32Array|string} password The password.\n   * @param {Word32Array|string} salt A salt.\n   * @param {Partial<EvpKDFProps>?} props (Optional) The configuration options to use for this computation.\n   * @return {Word32Array} The derived key.\n   * @static\n   * @example\n   *\n   *     var key = EvpKDF.getKey(password, salt);\n   *     var key = EvpKDF.getKey(password, salt, { keySize: 8 });\n   *     var key = EvpKDF.getKey(password, salt, { keySize: 8, iterations: 1000 });\n   */\n  public static getKey(password: Word32Array|string, salt: Word32Array|string, props?: Partial<EvpKDFProps>){\n    return new EvpKDF(props).compute(password, salt);\n  }\n}"]}
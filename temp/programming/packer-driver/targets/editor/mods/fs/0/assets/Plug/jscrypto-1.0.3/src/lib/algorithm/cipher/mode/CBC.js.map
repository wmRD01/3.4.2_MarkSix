{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/mode/CBC.ts"],"names":["CBC","BlockCipherMode","constructor","props","xorBlock","words","offset","blockSize","block","iv","_iv","undefined","_prevBlock","i","createEncryptor","Encryptor","createDecryptor","Decryptor","processBlock","cipher","_cipher","encryptBlock","slice","thisBlock","decryptBlock"],"mappings":";;;+CAKaA,G;;;;;;;;;;;;;;;;;;;;AALLC,MAAAA,e,iBAAAA,e;;;;;;;qBAKKD,G,GAAN,MAAMA,GAAN;AAAA;AAAA,8CAAkC;AAEvC;AACF;AACA;;AAwBE;AACF;AACA;AA4BSE,QAAAA,WAAW,CAACC,KAAD,EAAkB;AAClC,gBAAMA,KAAN;;AADkC,8CAzDH,EAyDG;AAEnC;;AAEMC,QAAAA,QAAQ,CAACC,KAAD,EAAkBC,MAAlB,EAAkCC,SAAlC,EAAoD;AACjE,cAAIC,KAAJ,CADiE,CAGjE;;AACA,gBAAMC,EAAE,GAAG,KAAKC,GAAhB,CAJiE,CAMjE;;AACA,cAAID,EAAJ,EAAO;AACLD,YAAAA,KAAK,GAAGC,EAAE,CAACJ,KAAX,CADK,CAGL;;AACA,iBAAKK,GAAL,GAAWC,SAAX;AACD,WALD,MAMK;AACHH,YAAAA,KAAK,GAAG,KAAKI,UAAb;AACD,WAfgE,CAiBjE;;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,SAApB,EAA+BM,CAAC,EAAhC,EAAoC;AAClCR,YAAAA,KAAK,CAACC,MAAM,GAAGO,CAAV,CAAL,IAAqBL,KAAK,CAACK,CAAD,CAA1B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC+B,eAAfC,eAAe,CAACX,KAAD,EAAiB;AAC5C,iBAAO,IAAIH,GAAG,CAACe,SAAR,CAAkBZ,KAAlB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC+B,eAAfa,eAAe,CAACb,KAAD,EAAiB;AAC5C,iBAAO,IAAIH,GAAG,CAACiB,SAAR,CAAkBd,KAAlB,CAAP;AACD;;AAvGsC,O;;sBAA5BH,G,eAK2B,MAAMe,SAAN,SAAwBf,GAAxB,CAA4B;AAChE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACWkB,QAAAA,YAAY,CAACb,KAAD,EAAkBC,MAAlB,EAAiC;AAClD;AACA,gBAAMa,MAAM,GAAG,KAAKC,OAApB;AACA,gBAAMb,SAAS,GAAGY,MAAM,CAACZ,SAAzB,CAHkD,CAKlD;;AACA,eAAKH,QAAL,CAAcC,KAAd,EAAqBC,MAArB,EAA6BC,SAA7B;AACAY,UAAAA,MAAM,CAACE,YAAP,CAAoBhB,KAApB,EAA2BC,MAA3B,EAPkD,CASlD;;AACA,eAAKM,UAAL,GAAkBP,KAAK,CAACiB,KAAN,CAAYhB,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AACD;;AApB+D,O;;sBALvDP,G,eA+B2B,MAAMiB,SAAN,SAAwBjB,GAAxB,CAA4B;AAChE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACWkB,QAAAA,YAAY,CAACb,KAAD,EAAkBC,MAAlB,EAAiC;AAClD;AACA,gBAAMa,MAAM,GAAG,KAAKC,OAApB;AACA,gBAAMb,SAAS,GAAGY,MAAM,CAACZ,SAAzB,CAHkD,CAKlD;;AACA,gBAAMgB,SAAS,GAAGlB,KAAK,CAACiB,KAAN,CAAYhB,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB,CANkD,CAQlD;;AACAY,UAAAA,MAAM,CAACK,YAAP,CAAoBnB,KAApB,EAA2BC,MAA3B;AACA,eAAKF,QAAL,CAAcC,KAAd,EAAqBC,MAArB,EAA6BC,SAA7B,EAVkD,CAYlD;;AACA,eAAKK,UAAL,GAAkBW,SAAlB;AACD;;AAvB+D,O","sourcesContent":["import {BlockCipherMode, BlockCipherModeProps} from \"./BlockCipherMode\";\n\nexport interface CBCProps extends BlockCipherModeProps {\n}\n\nexport class CBC extends BlockCipherMode {\n  protected _prevBlock: number[] = [];\n  /**\n   * CBC encryptor.\n   */\n  public static Encryptor: typeof CBC = class Encryptor extends CBC {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      // Shortcuts\n      const cipher = this._cipher;\n      const blockSize = cipher.blockSize;\n  \n      // XOR and encrypt\n      this.xorBlock(words, offset, blockSize);\n      cipher.encryptBlock(words, offset);\n  \n      // Remember this block to use with next block\n      this._prevBlock = words.slice(offset, offset + blockSize);\n    }\n  };\n  \n  /**\n   * CBC decryptor.\n   */\n  public static Decryptor: typeof CBC = class Decryptor extends CBC {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      // Shortcuts\n      const cipher = this._cipher;\n      const blockSize = cipher.blockSize;\n    \n      // Remember this block to use with next block\n      const thisBlock = words.slice(offset, offset + blockSize);\n    \n      // Decrypt and XOR\n      cipher.decryptBlock(words, offset);\n      this.xorBlock(words, offset, blockSize);\n    \n      // This block becomes the previous block\n      this._prevBlock = thisBlock;\n    }\n    \n  };\n  \n  public constructor(props: CBCProps) {\n    super(props);\n  }\n  \n  public xorBlock(words: number[], offset: number, blockSize: number){\n    let block: number[];\n  \n    // Shortcut\n    const iv = this._iv;\n  \n    // Choose mixing block\n    if (iv){\n      block = iv.words;\n    \n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    else {\n      block = this._prevBlock;\n    }\n  \n    // XOR blocks\n    for (let i = 0; i < blockSize; i++) {\n      words[offset + i] ^= block[i];\n    }\n  }\n  \n  /**\n   * Creates this mode for encryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CBC.createEncryptor(cipher, iv.words);\n   */\n  public static createEncryptor(props: CBCProps){\n    return new CBC.Encryptor(props);\n  }\n  \n  /**\n   * Creates this mode for decryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CBC.createDecryptor(cipher, iv.words);\n   */\n  public static createDecryptor(props: CBCProps){\n    return new CBC.Decryptor(props);\n  }\n}\n"]}
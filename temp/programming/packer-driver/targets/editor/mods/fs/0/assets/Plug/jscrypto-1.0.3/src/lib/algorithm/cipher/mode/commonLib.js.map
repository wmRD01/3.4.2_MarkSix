{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/mode/commonLib.ts"],"names":["padTo128m","w","remainder","nSigBytes","nPaddingBytes","pad","maxI","Math","floor","i","push","concat","msb","bytes","words","slice","lsb","n","nShift","lsbWords","j","byteIndex","wordIndex","b","wLsb","clamp","Word32Array"],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACO,WAASA,SAAT,CAAmBC,CAAnB,EAAkC;AACvC,UAAMC,SAAS,GAAGD,CAAC,CAACE,SAAF,GAAc,EAAhC;;AACA,QAAGD,SAAS,KAAK,CAAjB,EAAmB;AACjB;AACD;;AACD,UAAME,aAAa,GAAG,KAAKF,SAA3B,CALuC,CAOvC;;AACA,UAAMG,GAAG,GAAG,EAAZ;AACA,UAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWJ,aAAa,GAAC,CAAzB,CAAb;;AACA,SAAI,IAAIK,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACH,IAAd,EAAmBG,CAAC,EAApB,EAAuB;AACrBJ,MAAAA,GAAG,CAACK,IAAJ,CAAS,CAAT;AACD;;AAED,QAAGN,aAAa,GAAG,CAAhB,GAAoB,CAAvB,EAAyB;AACvBC,MAAAA,GAAG,CAACK,IAAJ,CAAS,CAAT;AACD;;AAEDT,IAAAA,CAAC,CAACU,MAAF,CAAS;AAAA;AAAA,oCAAgBN,GAAhB,EAAqBD,aAArB,CAAT;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,WAASQ,GAAT,CAAaX,CAAb,EAA6BY,KAA7B,EAA2C;AAChD,WAAO;AAAA;AAAA,oCAAgBZ,CAAC,CAACa,KAAF,CAAQC,KAAR,EAAhB,EAAiCF,KAAjC,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,WAASG,GAAT,CAAaf,CAAb,EAA6BY,KAA7B,EAA2C;AAChD,UAAMI,CAAC,GAAGhB,CAAC,CAACE,SAAZ;AACA,UAAMe,MAAM,GAAGD,CAAC,GAAGJ,KAAnB;AACA,UAAMM,QAAkB,GAAG,EAA3B;;AAEA,SAAI,IAAIV,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACI,KAAd,EAAoBJ,CAAC,EAArB,EAAwB;AACtB,YAAMW,CAAC,GAAGX,CAAC,KAAK,CAAhB;AACA,YAAMY,SAAS,GAAGH,MAAM,GAAGT,CAA3B;AACA,YAAMa,SAAS,GAAGD,SAAS,KAAK,CAAhC;AACA,YAAME,CAAC,GAAItB,CAAC,CAACa,KAAF,CAAQQ,SAAR,MAAwB,KAAMD,SAAS,GAAG,CAAb,GAAgB,CAA9C,GAAoD,UAA9D;AACAF,MAAAA,QAAQ,CAACC,CAAD,CAAR,GAAeD,QAAQ,CAACC,CAAD,CAAR,GAAc,CAAf,GAAqBG,CAAC,IAAK,KAAMd,CAAC,GAAG,CAAL,GAAQ,CAAtD;AACD;;AAED,UAAMe,IAAI,GAAG;AAAA;AAAA,oCAAgBL,QAAhB,EAA0BN,KAA1B,CAAb;AACAW,IAAAA,IAAI,CAACC,KAAL;AACA,WAAOD,IAAP;AACD;;;;;;;eAzDexB,S;SA6BAY,G;SAYAI;;;;;;;;;AAhDRU,MAAAA,W,iBAAAA,W","sourcesContent":["import {Word32Array} from \"../../../Word32Array\";\n\n/**\n * Pad word array to multiple of 128bit(4byte)\n * @param {Word32Array} w - Padding target. This w will be modified directly.\n * @returns {void}\n */\nexport function padTo128m(w: Word32Array){\n  const remainder = w.nSigBytes % 16;\n  if(remainder === 0){\n    return;\n  }\n  const nPaddingBytes = 16 - remainder;\n  \n  // Pad Ciphertext\n  const pad = [];\n  const maxI = Math.floor(nPaddingBytes/4);\n  for(let i=0;i<maxI;i++){\n    pad.push(0);\n  }\n  \n  if(nPaddingBytes % 4 > 0){\n    pad.push(0);\n  }\n  \n  w.concat(new Word32Array(pad, nPaddingBytes));\n}\n\n/**\n * Extract Most Significant Bit.\n * @param {Word32Array} w\n * @param {number} bytes - Number of bytes to extract\n * @example\n *   const w = new Word32Array([0x11223344, 0x55667788]);\n *   msb(w, 2).toString() === \"1122\"; // true\n */\nexport function msb(w: Word32Array, bytes: number){\n  return new Word32Array(w.words.slice(), bytes);\n}\n\n/**\n * Extract Least Significant Bit.\n * @param {Word32Array} w\n * @param {number} bytes - Number of bytes to extract\n * @example\n *   const w = new Word32Array([0x11223344, 0x55667788, 0x99aabb00], 11);\n *   lsb(w, 5).toString() === \"778899aabb\"; // true\n */\nexport function lsb(w: Word32Array, bytes: number){\n  const n = w.nSigBytes;\n  const nShift = n - bytes;\n  const lsbWords: number[] = [];\n  \n  for(let i=0;i<bytes;i++){\n    const j = i >>> 2;\n    const byteIndex = nShift + i;\n    const wordIndex = byteIndex >>> 2;\n    const b = (w.words[wordIndex] >>> (24 - (byteIndex % 4)*8)) & 0x000000ff;\n    lsbWords[j] = (lsbWords[j] | 0) | (b << (24 - (i % 4)*8));\n  }\n  \n  const wLsb = new Word32Array(lsbWords, bytes);\n  wLsb.clamp();\n  return wLsb;\n}\n"]}
{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/encoder/Base64.ts"],"names":["Word32Array","map","reverseMap","i","length","charCodeAt","Base64","stringify","w","words","sigBytes","nSigBytes","clamp","base64Chars","byte1","byte2","byte3","triplet","j","push","charAt","paddingChar","join","parse","base64Str","base64StrLength","paddingIndex","indexOf","nBytes","bits1","bits2","bitsCombined"],"mappings":"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","sourcesContent":["import type {IEncoder} from \"../type\";\nimport {Word32Array} from \"../Word32Array\";\n\nconst map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst reverseMap: number[] = [];\nfor(let i=0;i<map.length;i++){\n  reverseMap[map.charCodeAt(i)] = i;\n}\n\nexport const Base64: IEncoder = {\n  /**\n   * Converts a word array to a base64 string.\n   *\n   * @param {Word32Array} w An array of 32-bit words.\n   * @return {string} The base64 string.\n   * @example\n   *   var hexString = Base64.stringify(new Word32Array([0x293892], 6));\n   */\n  stringify(w: Word32Array){\n    // Shortcuts\n    const words = w.words;\n    const sigBytes = w.nSigBytes;\n  \n    // Clamp excess bits\n    w.clamp();\n  \n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n  \n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n    \n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n  \n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n  \n    return base64Chars.join(\"\");\n  },\n  \n  /**\n   * Converts a base64 string to a word array.\n   *\n   * @param {string} base64Str The base64 string.\n   * @return {Word32Array} The word array.\n   * @example\n   *   var wordArray = Base64.parse(base64String);\n   */\n  parse(base64Str: string){\n    let base64StrLength = base64Str.length;\n    \n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if(paddingChar){\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if(paddingIndex !== -1){\n        base64StrLength = paddingIndex;\n      }\n    }\n    \n    const words: number[] = [];\n    let nBytes = 0;\n    \n    for(let i=0;i<base64StrLength;i++){\n      if(i%4){\n        const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n        const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n        const bitsCombined = bits1 | bits2;\n        words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n        nBytes++;\n      }\n    }\n    \n    return new Word32Array(words, nBytes);\n  }\n}\n"]}
{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/BlockCipher.ts"],"names":["BlockCipher","Cipher","CBC","Pkcs7","constructor","props","_props","_Mode","mode","_padding","padding","reset","data","nBytes","_mode","modeCreator","_transformMode","ENC_TRANSFORM_MODE","createEncryptor","createDecryptor","_minBufferSize","_modeCreator","cipher","iv","_iv","call","_doProcessBlock","words","offset","processBlock","_doFinalize","finalProcessedBlocks","pad","_data","blockSize","_process","unpad","encryptBlock","Error","decryptBlock","key","transformMode","DEC_TRANSFORM_MODE"],"mappings":";;;kDAkBaA,W;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlBLC,MAAAA,M,iBAAAA,M;;AAEAC,MAAAA,G,iBAAAA,G;;AAEAC,MAAAA,K,iBAAAA,K;;;;;;;6BAcKH,W,GAAN,MAAMA,WAAN;AAAA;AAAA,4BAAiC;AAa/BI,QAAAA,WAAW,CAACC,KAAD,EAAwC;AACxD,gBAAMA,KAAN;;AADwD;;AAAA,8CAXnC,MAAI,EAW+B;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAExD,eAAKC,MAAL,GAAcD,KAAd;AAEA,eAAKE,KAAL,GAAa,OAAOF,KAAK,CAACG,IAAb,KAAsB,WAAtB,GAAoCH,KAAK,CAACG,IAA1C,GAAiD,KAAKD,KAAnE;AACA,eAAKE,QAAL,GAAgB,OAAOJ,KAAK,CAACK,OAAb,KAAyB,WAAzB,GAAuCL,KAAK,CAACK,OAA7C,GAAuD,KAAKD,QAA5E;AAEA,eAAKE,KAAL,CAAWN,KAAX,aAAWA,KAAX,uBAAWA,KAAK,CAAEO,IAAlB,EAAwBP,KAAxB,aAAwBA,KAAxB,uBAAwBA,KAAK,CAAEQ,MAA/B;AACD;;AAEc,YAAJL,IAAI,GAAE;AACf,iBAAO,KAAKM,KAAZ;AACD;;AAEiB,YAAPJ,OAAO,GAAE;AAClB,iBAAO,KAAKD,QAAZ;AACD;;AAEDE,QAAAA,KAAK,CAACC,IAAD,EAAqBC,MAArB,EAAsC;AACzC,gBAAMF,KAAN,CAAYC,IAAZ,EAAkBC,MAAlB;AAEA,cAAIE,WAAJ;;AACA,cAAG,KAAKC,cAAL,KAAwB;AAAA;AAAA,gCAAOC,kBAAlC,EAAqD;AACnDF,YAAAA,WAAW,GAAG,KAAKR,KAAL,CAAWW,eAAzB;AACD,WAFD,MAGI;AACFH,YAAAA,WAAW,GAAG,KAAKR,KAAL,CAAWY,eAAzB,CADE,CAEF;;AACA,iBAAKC,cAAL,GAAsB,CAAtB;AACD;;AAED,cAAG,KAAKb,KAAL,IAAc,KAAKc,YAAL,KAAqBN,WAAtC,EAAkD;AAChD,iBAAKD,KAAL,GAAa,IAAI,KAAKP,KAAT,CAAe;AAACe,cAAAA,MAAM,EAAE,IAAT;AAAeC,cAAAA,EAAE,EAAE,KAAKC;AAAxB,aAAf,CAAb;AACD,WAFD,MAGI;AACF,iBAAKV,KAAL,GAAaC,WAAW,CAACU,IAAZ,CAAiB,KAAKlB,KAAtB,EAA6B;AAACe,cAAAA,MAAM,EAAE,IAAT;AAAeC,cAAAA,EAAE,EAAE,KAAKC;AAAxB,aAA7B,CAAb;AACA,iBAAKH,YAAL,GAAoBN,WAApB;AACD;AACF;;AAESW,QAAAA,eAAe,CAACC,KAAD,EAAkBC,MAAlB,EAAkC;AAAA;;AACzD,8BAAKd,KAAL,4DAAYe,YAAZ,CAAyBF,KAAzB,EAAgCC,MAAhC;AACD;;AAESE,QAAAA,WAAW,GAAgB;AACnC,cAAIC,oBAAJ,CADmC,CAGnC;;AACA,cAAMrB,OAAO,GAAG,KAAKD,QAArB,CAJmC,CAMnC;;AACA,cAAI,KAAKO,cAAL,KAAwB;AAAA;AAAA,gCAAOC,kBAAnC,EAAuD;AACrD;AACAP,YAAAA,OAAO,CAACsB,GAAR,CAAY,KAAKC,KAAjB,EAAwB,KAAKC,SAA7B,EAFqD,CAIrD;;AACAH,YAAAA,oBAAoB,GAAG,KAAKI,QAAL,CAAc,IAAd,CAAvB;AACD,WAND;AAOK;AAA6D;AAChE;AACAJ,cAAAA,oBAAoB,GAAG,KAAKI,QAAL,CAAc,IAAd,CAAvB,CAFgE,CAIhE;;AACAzB,cAAAA,OAAO,CAAC0B,KAAR,CAAcL,oBAAd;AACD;;AAED,iBAAOA,oBAAP;AACD;AAED;AACF;AACA;;;AACSM,QAAAA,YAAY,CAACV,KAAD,EAAkBC,MAAlB,EAAwC;AACzD,gBAAM,IAAIU,KAAJ,CAAU,iBAAV,CAAN;AACD;AAED;AACF;AACA;;;AACSC,QAAAA,YAAY,CAACZ,KAAD,EAAkBC,MAAlB,EAAwC;AACzD,gBAAM,IAAIU,KAAJ,CAAU,iBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC+B,eAAfpB,eAAe,CAACsB,GAAD,EAAmBnC,KAAnB,EAAqD;AAChFA,UAAAA,KAAK,GAAG,OAAOA,KAAP,KAAiB,WAAjB,GAA+B,EAA/B,GAAoCA,KAA5C;AACA,iBAAO,IAAIL,WAAJ,cAAoBK,KAApB;AAA2BmC,YAAAA,GAA3B;AAAgCC,YAAAA,aAAa,EAAE;AAAA;AAAA,kCAAOxB;AAAtD,aAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC+B,eAAfE,eAAe,CAACqB,GAAD,EAAmBnC,KAAnB,EAAqD;AAChFA,UAAAA,KAAK,GAAG,OAAOA,KAAP,KAAiB,WAAjB,GAA+B,EAA/B,GAAoCA,KAA5C;AACA,iBAAO,IAAIL,WAAJ,cAAoBK,KAApB;AAA2BmC,YAAAA,GAA3B;AAAgCC,YAAAA,aAAa,EAAE;AAAA;AAAA,kCAAOC;AAAtD,aAAP;AACD;;AAzHqC,O","sourcesContent":["import {Cipher, CipherProps, PropsWithKey} from \"./Cipher\";\nimport type {BlockCipherMode, BlockCipherModeProps} from \"./mode/BlockCipherMode\";\nimport {CBC} from \"./mode/CBC\";\nimport type {Pad} from \"./pad/type\";\nimport {Pkcs7} from \"./pad/Pkcs7\";\nimport type {Word32Array} from \"../../Word32Array\";\nimport type {BaseKDFModule} from \"./kdf/type\";\nimport type {Hasher} from \"../Hasher\";\n\nexport interface BlockCipherProps extends CipherProps {\n  mode: typeof BlockCipherMode;\n  padding: Pad;\n  kdfSalt: Word32Array; // 64bit. word32Array. 8words.\n  kdfModule: typeof BaseKDFModule;\n  kdfHasher: typeof Hasher;\n  kdfIterations: number;\n}\n\nexport class BlockCipher extends Cipher {\n  protected _props: PropsWithKey<BlockCipherProps>;\n  protected _blockSize = 128/32;\n  protected _Mode: typeof BlockCipherMode = CBC;\n  protected _mode?: BlockCipherMode;\n  protected _padding: Pad = Pkcs7;\n  protected _modeCreator?: (props: BlockCipherModeProps) => BlockCipherMode;\n  \n  /**\n   * @see https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146\n   */\n  [\"constructor\"]!: typeof BlockCipher;\n  \n  public constructor(props: PropsWithKey<BlockCipherProps>) {\n    super(props);\n    this._props = props;\n  \n    this._Mode = typeof props.mode !== \"undefined\" ? props.mode : this._Mode;\n    this._padding = typeof props.padding !== \"undefined\" ? props.padding : this._padding;\n  \n    this.reset(props?.data, props?.nBytes);\n  }\n  \n  public get mode(){\n    return this._mode;\n  }\n  \n  public get padding(){\n    return this._padding;\n  }\n  \n  reset(data?: Word32Array, nBytes?: number) {\n    super.reset(data, nBytes);\n    \n    let modeCreator: (props: BlockCipherModeProps) => BlockCipherMode;\n    if(this._transformMode === Cipher.ENC_TRANSFORM_MODE){\n      modeCreator = this._Mode.createEncryptor;\n    }\n    else{\n      modeCreator = this._Mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n    \n    if(this._Mode && this._modeCreator=== modeCreator){\n      this._mode = new this._Mode({cipher: this, iv: this._iv});\n    }\n    else{\n      this._mode = modeCreator.call(this._Mode, {cipher: this, iv: this._iv});\n      this._modeCreator = modeCreator;\n    }\n  }\n  \n  protected _doProcessBlock(words: number[], offset: number) {\n    this._mode?.processBlock(words, offset);\n  }\n  \n  protected _doFinalize(): Word32Array {\n    let finalProcessedBlocks: Word32Array;\n  \n    // Shortcut\n    const padding = this._padding;\n  \n    // Finalize\n    if (this._transformMode === Cipher.ENC_TRANSFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n    \n      // Process final blocks\n      finalProcessedBlocks = this._process(true);\n    }\n    else /* if (this._transformMode == Cipher._DEC_TRANSFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(true);\n    \n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n  \n    return finalProcessedBlocks;\n  }\n  \n  /**\n   * @abstract\n   */\n  public encryptBlock(words: number[], offset: number): void {\n    throw new Error(\"Not implemented\");\n  }\n  \n  /**\n   * @abstract\n   */\n  public decryptBlock(words: number[], offset: number): void {\n    throw new Error(\"Not implemented\");\n  }\n  \n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {Word32Array} key The key.\n   * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\n   * @return {Cipher} A cipher instance.\n   * @example\n   *     var cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  public static createEncryptor(key: Word32Array, props?: Partial<BlockCipherProps>){\n    props = typeof props === \"undefined\" ? {} : props;\n    return new BlockCipher({...props, key, transformMode: Cipher.ENC_TRANSFORM_MODE});\n  }\n  \n  /**\n   * Creates this cipher in decryption mode.\n   * @param {Word32Array} key The key.\n   * @param {Partial<CipherProps>?} props (Optional) The configuration options to use for this operation.\n   * @return {Cipher} A cipher instance.\n   * @example\n   *   var cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  public static createDecryptor(key: Word32Array, props?: Partial<BlockCipherProps>){\n    props = typeof props === \"undefined\" ? {} : props;\n    return new BlockCipher({...props, key, transformMode: Cipher.DEC_TRANSFORM_MODE});\n  }\n}\n"]}
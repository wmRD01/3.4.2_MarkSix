{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/mode/CFB.ts"],"names":["CFB","BlockCipherMode","constructor","props","generateKeyStreamAndEncrypt","words","offset","blockSize","cipher","keyStream","iv","_iv","slice","undefined","_prevBlock","encryptBlock","i","createEncryptor","Encryptor","createDecryptor","Decryptor","processBlock","_cipher","thisBlock"],"mappings":";;;+CAMaA,G;;;;;;;;;;;;;;;;;;;;;;;;AANLC,MAAAA,e,iBAAAA,e;;;;;;;AAGR;AACA;AACA;qBACaD,G,GAAN,MAAMA,GAAN;AAAA;AAAA,8CAAkC;AAGvC;AACF;AACA;;AAkBE;AACF;AACA;AAqBSE,QAAAA,WAAW,CAACC,KAAD,EAA8B;AAC9C,gBAAMA,KAAN;;AAD8C,8CA7Cf,EA6Ce;AAE/C;;AAEMC,QAAAA,2BAA2B,CAACC,KAAD,EAAkBC,MAAlB,EAAkCC,SAAlC,EAAqDC,MAArD,EAAyE;AACzG,cAAIC,SAAJ,CADyG,CAGzG;;AACA,cAAMC,EAAE,GAAG,KAAKC,GAAhB,CAJyG,CAMzG;;AACA,cAAID,EAAJ,EAAQ;AACND,YAAAA,SAAS,GAAGC,EAAE,CAACL,KAAH,CAASO,KAAT,CAAe,CAAf,CAAZ,CADM,CAGN;;AACA,iBAAKD,GAAL,GAAWE,SAAX;AACD,WALD,MAMK;AACHJ,YAAAA,SAAS,GAAG,KAAKK,UAAjB;AACD;;AACDN,UAAAA,MAAM,CAACO,YAAP,CAAoBN,SAApB,EAA+B,CAA/B,EAhByG,CAkBzG;;AACA,eAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAApB,EAA+BS,CAAC,EAAhC,EAAoC;AAClCX,YAAAA,KAAK,CAACC,MAAM,GAAGU,CAAV,CAAL,IAAqBP,SAAS,CAACO,CAAD,CAA9B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC+B,eAAfC,eAAe,CAACd,KAAD,EAA6B;AACxD,iBAAO,IAAIH,GAAG,CAACkB,SAAR,CAAkBf,KAAlB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AAC+B,eAAfgB,eAAe,CAAChB,KAAD,EAA6B;AACxD,iBAAO,IAAIH,GAAG,CAACoB,SAAR,CAAkBjB,KAAlB,CAAP;AACD;;AA5FsC,O;;sBAA5BH,G,eAM2B,MAAMkB,SAAN,SAAwBlB,GAAxB,CAA4B;AAChE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACWqB,QAAAA,YAAY,CAAChB,KAAD,EAAkBC,MAAlB,EAAiC;AAClD,eAAKF,2BAAL,CAAiCC,KAAjC,EAAwCC,MAAxC,EAAgD,KAAKgB,OAAL,CAAaf,SAA7D,EAAwE,KAAKe,OAA7E,EADkD,CAGlD;;AACA,eAAKR,UAAL,GAAkBT,KAAK,CAACO,KAAN,CAAYN,MAAZ,EAAoBA,MAAM,GAAG,KAAKgB,OAAL,CAAaf,SAA1C,CAAlB;AACD;;AAd+D,O;;sBANvDP,G,eA0B2B,MAAMkB,SAAN,SAAwBlB,GAAxB,CAA4B;AAChE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACWqB,QAAAA,YAAY,CAAChB,KAAD,EAAkBC,MAAlB,EAAiC;AAClD;AACA,cAAMiB,SAAS,GAAGlB,KAAK,CAACO,KAAN,CAAYN,MAAZ,EAAoBA,MAAM,GAAG,KAAKgB,OAAL,CAAaf,SAA1C,CAAlB;AAEA,eAAKH,2BAAL,CAAiCC,KAAjC,EAAwCC,MAAxC,EAAgD,KAAKgB,OAAL,CAAaf,SAA7D,EAAwE,KAAKe,OAA7E,EAJkD,CAMlD;;AACA,eAAKR,UAAL,GAAkBS,SAAlB;AACD;;AAjB+D,O","sourcesContent":["import {BlockCipherMode, BlockCipherModeProps} from \"./BlockCipherMode\";\nimport type {BlockCipher} from \"../BlockCipher\";\n\n/**\n * Cipher Feedback Block mode\n */\nexport class CFB extends BlockCipherMode {\n  protected _prevBlock: number[] = [];\n  \n  /**\n   * CFB encryptor.\n   */\n  public static Encryptor: typeof CFB = class Encryptor extends CFB {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      this.generateKeyStreamAndEncrypt(words, offset, this._cipher.blockSize, this._cipher);\n  \n      // Remember this block to use with next block\n      this._prevBlock = words.slice(offset, offset + this._cipher.blockSize);\n    }\n  };\n  \n  /**\n   * CFB decryptor.\n   */\n  public static Decryptor: typeof CFB = class Encryptor extends CFB {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      // Remember this block to use with next block\n      const thisBlock = words.slice(offset, offset + this._cipher.blockSize);\n  \n      this.generateKeyStreamAndEncrypt(words, offset, this._cipher.blockSize, this._cipher);\n  \n      // This block becomes the previous block\n      this._prevBlock = thisBlock;\n    }\n  };\n  \n  public constructor(props: BlockCipherModeProps) {\n    super(props);\n  }\n  \n  public generateKeyStreamAndEncrypt(words: number[], offset: number, blockSize: number, cipher: BlockCipher){\n    let keyStream;\n  \n    // Shortcut\n    const iv = this._iv;\n  \n    // Generate keyStream\n    if (iv) {\n      keyStream = iv.words.slice(0);\n    \n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    else {\n      keyStream = this._prevBlock;\n    }\n    cipher.encryptBlock(keyStream, 0);\n  \n    // Encrypt\n    for (let i = 0; i < blockSize; i++) {\n      words[offset + i] ^= keyStream[i];\n    }\n  }\n  \n  /**\n   * Creates this mode for encryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CFB.createEncryptor(cipher, iv.words);\n   */\n  public static createEncryptor(props: BlockCipherModeProps){\n    return new CFB.Encryptor(props);\n  }\n  \n  /**\n   * Creates this mode for decryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CFB.createDecryptor(cipher, iv.words);\n   */\n  public static createDecryptor(props: BlockCipherModeProps){\n    return new CFB.Decryptor(props);\n  }\n}"]}
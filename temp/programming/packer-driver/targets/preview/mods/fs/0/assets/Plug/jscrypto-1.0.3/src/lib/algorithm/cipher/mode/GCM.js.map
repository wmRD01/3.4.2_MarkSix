{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Plug/jscrypto-1.0.3/src/lib/algorithm/cipher/mode/GCM.ts"],"names":["GCM","BlockCipherMode","Word32Array","msb","padTo128m","constructor","props","cipher","blockSize","Error","iv","H","encryptBlock","_H","_J0","getJ0","words","_CB","slice","J0","length","remainderOf4Word","iv2","i","push","GHASH","inc32","X","A","unsignedX3","carry3","unsignedX2","carry2","mul","Y","R","Z","V","xIndex","xi","LSBVi","carry0","carry1","m","GCTR","ICB","nSigBytes","clone","n","Math","ceil","CB","CBi","remainderOf16Bytes","Yi0","Yi1","Yi2","Yi3","Yi","concat","w","nMaxAligned","floor","k","Ynk","remaining0to3Bytes","Ynr","Yn","clamp","mac","Cipher","key","aad","cipherText","tagLength","lenA","C","lenC","lenT","s","S","MAC","createEncryptor","Encryptor","createDecryptor","Decryptor","processBlock","offset","_cipher","plainText","P"],"mappings":"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","sourcesContent":["import {BlockCipherMode, BlockCipherModeProps} from \"./BlockCipherMode\";\nimport {Word32Array} from \"../../../Word32Array\";\nimport type {BlockCipher} from \"../BlockCipher\";\nimport {msb, padTo128m} from \"./commonLib\";\n\n/**\n * Galois Counter Mode\n */\nexport class GCM extends BlockCipherMode {\n  protected _H: number[] = [];\n  protected _J0: number[] = [];\n  protected _CB: number[] = []; // Counter Block\n  \n  public constructor(props: BlockCipherModeProps) {\n    super(props);\n    \n    if(props.cipher.blockSize !== 128/32){\n      throw new Error(\"In GCM block cipher mode, cipher block size must be 128bit\");\n    }\n  \n    const {cipher, iv} = props;\n    const H = [0,0,0,0];\n    cipher.encryptBlock(H, 0);\n    this._H = H;\n  \n    // iv should be array of 32bit int\n    this._J0 = GCM.getJ0(H, iv?.words);\n    this._CB = this._J0.slice();\n  }\n  \n  /**\n   * Initialize Initial Counter Block J0.\n   * @param {[number, number, number, number]} H - 128bit(4word) block\n   * @param {number[]} iv - Initializing Vector which must be multiple of 32bit(4byte)\n   */\n  public static getJ0(H: number[], iv?: number[]){\n    let J0: number[];\n    if(!iv || iv.length === 0){\n      J0 = [0, 0, 0, 1];\n    }\n    else if(iv.length === 3){\n      J0 = [iv[0], iv[1], iv[2], 1];\n    }\n    else{\n      const remainderOf4Word = (iv.length % 4) > 0 ? 4 - (iv.length % 4) : 0;\n      const iv2 = iv.slice();\n    \n      for(let i=0;i<remainderOf4Word+2;i++){\n        iv2.push(0); // append 32bit 0\n      }\n    \n      // This should be upper 32bit of len(iv),\n      // But iv.length > 4294967295(0xffffffff, unsigned 32bit int max) is not supported for now.\n      iv2.push(0);\n    \n      iv2.push(iv.length * 32); // An element of `iv` is 4byte = 32bit.\n    \n      J0 = GCM.GHASH(H, iv2);\n    }\n    \n    return J0;\n  }\n  \n  /**\n   * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n   * 6.2 Incrementing Function  \n   * inc(s=32, X) = MSB(len(X)-s, X) || [int(LSB(s, X)+1 mod 2^s]\n   * \n   * @param {number[]} X - [32bit int, 32bit int, 32bit int, 32bit int].\n   * @example\n   *   inc32([0,0,0,0]) = [0,0,0,1]\n   *   inc32([0,0,0,1]) = [0,0,0,2]\n   *   inc32([0,0,0,0xffffffff]) = [0,0,1,0]\n   *   inc32([0,0,0xffffffff,0xffffffff]) = [0,1,0,0]\n   *   inc32([0,0xffffffff,0xffffffff,0xffffffff]) = [0,0,0,0]\n   */\n  public static inc32(X: number[]){\n    const A = X.slice();\n    const unsignedX3 = (A[3] >>> 0);\n    const carry3 = ((unsignedX3+1)>>>0) < unsignedX3;\n    A[3] = (A[3] + 1) | 0;\n    if(carry3){\n      const unsignedX2 = (A[2] >>> 0);\n      const carry2 = ((unsignedX2+1)>>>0) < unsignedX2;\n      A[2] = (A[2] + 1) | 0;\n      if(carry2){\n        A[1] = (A[1] + 1) | 0;\n      }\n    }\n    \n    return A;\n  }\n  \n  /**\n   * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n   * 6.3 Multiplication Operation on Blocks\n   *\n   * @param {number[]} X - [32bit int, 32bit int, 32bit int, 32bit int], 128bit block.\n   * @param {number[]} Y - [32bit int, 32bit int, 32bit int, 32bit int], 128bit block.\n   * @returns 128bit block\n   */\n  public static mul(X: number[], Y: number[]){\n    const R = [0xe1000000, 0, 0, 0];\n    const Z = [0, 0, 0, 0];\n    const V = Y.slice();\n    \n    for(let i=0;i<128;i++){\n      const xIndex = i >>> 5;\n      const xi = (X[xIndex] >>> (31-i%32)) & 1;\n      if(xi > 0){\n        Z[0] = Z[0] ^ V[0];\n        Z[1] = Z[1] ^ V[1];\n        Z[2] = Z[2] ^ V[2];\n        Z[3] = Z[3] ^ V[3];\n      }\n      const LSBVi = (V[3]&1) >>> 0;\n      const carry0 = (V[0]&1) >>> 0;\n      const carry1 = (V[1]&1) >>> 0;\n      const carry2 = (V[2]&1) >>> 0;\n      V[0] = V[0] >>> 1;\n      V[1] = (V[1] >>> 1) | (carry0 ? 0x80000000 : 0);\n      V[2] = (V[2] >>> 1) | (carry1 ? 0x80000000 : 0);\n      V[3] = (V[3] >>> 1) | (carry2 ? 0x80000000 : 0);\n      \n      if(LSBVi > 0){\n        V[0] ^= R[0];\n        V[1] ^= R[1];\n        V[2] ^= R[2];\n        V[3] ^= R[3];\n      }\n    }\n    \n    return Z;\n  }\n  \n  /**\n   * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n   * 6.4 GHASH Function\n   * \n   * @param {number[]} H - The hash sub key block of 128bit.\n   * @param {number[]} X - X.length must be multiple of 4. (multiple of 128bit)\n   * @returns 128bit block\n   */\n  public static GHASH(H: number[], X: number[]){\n    if(H.length % 4 !== 0){\n      throw new Error(\"Length of 32bit word array 'H' must be multiple of 4(128bit)\");\n    }\n    else if(X.length % 4 !== 0){\n      throw new Error(\"Length of 32bit word array 'X' must be multiple of 4(128bit)\");\n    }\n    \n    const m = X.length;\n    let Y = [0, 0, 0, 0];\n    for(let i=0;i<m;i+=4){\n      Y[0] = (Y[0] ^ X[i]);\n      Y[1] = (Y[1] ^ X[i+1]);\n      Y[2] = (Y[2] ^ X[i+2]);\n      Y[3] = (Y[3] ^ X[i+3]);\n      Y = GCM.mul(Y, H);\n    }\n    return Y;\n  }\n  \n  /**\n   * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n   * 6.5 GCTR Function\n   * \n   * @param {BlockCipher} cipher\n   * @param {number[]} ICB - Initial Code Block. Required to be 128bit(4word).\n   * @param {Word32Array} X - Arbitrary length block\n   */\n  public static GCTR(cipher: BlockCipher, ICB: number[], X: Word32Array){\n    if(X.nSigBytes === 0){\n      return X.clone();\n    }\n    if(ICB.length !== 4){\n      throw new Error(\"Initial Counter Block size must be 128bit\");\n    }\n    \n    const words = X.words;\n    const n = Math.ceil(X.nSigBytes / 16);\n    const CB = [ICB.slice()];\n    \n    for(let i=1;i<n;i++){\n      const CBi = GCM.inc32(CB[i-1]);\n      CB.push(CBi);\n    }\n    \n    const Y = new Word32Array();\n    for(let i=0;i<n;i++){\n      cipher.encryptBlock(CB[i], 0);\n      const remainderOf16Bytes = X.nSigBytes % 16;\n      \n      if(i < n-1 || /* i === n-1 && */ remainderOf16Bytes === 0){\n        const Yi0 = words[i*4] ^ CB[i][0];\n        const Yi1 = words[i*4+1] ^ CB[i][1];\n        const Yi2 = words[i*4+2] ^ CB[i][2];\n        const Yi3 = words[i*4+3] ^ CB[i][3];\n        const Yi = new Word32Array([Yi0, Yi1, Yi2, Yi3]);\n        Y.concat(Yi);\n        continue;\n      }\n      \n      // i === n-1\n      const w = [];\n      let nSigBytes = 0;\n      const nMaxAligned = Math.floor(remainderOf16Bytes/4);\n      for(let k=0;k<nMaxAligned;k++){\n        const Ynk = words[i*4+k] ^ CB[i][k];\n        w.push(Ynk);\n        nSigBytes += 4;\n      }\n      \n      const remaining0to3Bytes = remainderOf16Bytes % 4;\n      if(remaining0to3Bytes > 0){\n        const Ynr = (words[i*4+nMaxAligned] << (32-8*remaining0to3Bytes)) ^ CB[i][nMaxAligned];\n        w.push(Ynr);\n        nSigBytes += remaining0to3Bytes;\n      }\n      \n      const Yn = new Word32Array(w, nSigBytes);\n      Y.concat(Yn);\n    }\n    \n    Y.nSigBytes = X.nSigBytes;\n    Y.clamp();\n    return Y;\n  }\n  \n  /**\n   * Calculate Message Authentication Code with GCM\n   *\n   * @param {typeof BlockCipher} Cipher - 128 bit block Cipher i.e. AES\n   * @param {Word32Array} key - key\n   * @param {Word32Array} iv - iv should be 12byte length. i.e. `new Word32Array([0x11223344, 0x55667788, 0x99aabbcc], 12);`\n   * @param {Word32Array?} aad - Additional Authenticated Data\n   * @param {Word32Array?} cipherText - encrypted text\n   * @param {number?} tagLength - authTag size in octet length. If omitted, tagLength will be set to 16byte.\n   */\n  public static mac(\n    Cipher: typeof BlockCipher,\n    key: Word32Array,\n    iv: Word32Array,\n    aad?: Word32Array,\n    cipherText?: Word32Array,\n    tagLength?: number,\n  ){\n    const cipher = new Cipher({key, iv});\n    const H = [0,0,0,0];\n    cipher.encryptBlock(H, 0);\n    const J0 = GCM.getJ0(H, iv.words);\n    const A = aad?.clone() || new Word32Array();\n    const lenA = [0, A.nSigBytes*8];\n    const C = cipherText?.clone() || new Word32Array();\n    const lenC = [0, C.nSigBytes*8];\n    const lenT = tagLength || 16;\n  \n    // Pad\n    padTo128m(A);\n    padTo128m(C);\n  \n    const s = A.words.concat(C.words).concat(lenA).concat(lenC);\n    const S = GCM.GHASH(H, s);\n    const MAC = GCM.GCTR(cipher, J0, new Word32Array(S));\n    return msb(MAC, lenT);\n  }\n  \n  /**\n   * CTR encryptor.\n   */\n  public static Encryptor: typeof GCM = class Encryptor extends GCM {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      // Shortcuts\n      const cipher = this._cipher\n      const blockSize = cipher.blockSize;\n      \n      // Encrypt with CTR mode\n      this._CB = GCM.inc32(this._CB);\n      const plainText = new Word32Array(words.slice(offset, offset+blockSize));\n      const C = GCM.GCTR(this._cipher, this._CB, plainText);\n      for(let i=0;i<blockSize;i++){\n        words[offset + i] = C.words[i];\n      }\n    }\n  };\n  \n  /**\n   * CTR decryptor.\n   */\n  public static Decryptor: typeof GCM = class Decryptor extends GCM {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {number[]} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     * @example\n     *   mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: number[], offset: number){\n      // Shortcuts\n      const cipher = this._cipher\n      const blockSize = cipher.blockSize;\n    \n      // Decrypt with CTR mode\n      this._CB = GCM.inc32(this._CB);\n      const C = new Word32Array(words.slice(offset, offset+blockSize));\n      const P = GCM.GCTR(this._cipher, this._CB, C);\n      for(let i=0;i<blockSize;i++){\n        words[offset + i] = P.words[i];\n      }\n    }\n  };\n  \n  /**\n   * Creates this mode for encryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CTR.createEncryptor(cipher, iv.words);\n   */\n  public static createEncryptor(props: BlockCipherModeProps){\n    return new GCM.Encryptor(props);\n  }\n  \n  /**\n   * Creates this mode for decryption.\n   * @param {BlockCipherModeProps} props\n   * @example\n   *   var mode = CTR.createDecryptor(cipher, iv.words);\n   */\n  public static createDecryptor(props: BlockCipherModeProps){\n    return new GCM.Decryptor(props);\n  }\n}"]}
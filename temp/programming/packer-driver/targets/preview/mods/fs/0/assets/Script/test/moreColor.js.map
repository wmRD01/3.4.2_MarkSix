{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/assets/Script/test/moreColor.ts"],"names":[],"mappings":"AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import { _decorator, Component, Enum, Color, log, RenderComponent, Sprite } from \"cc\";\r\n\r\n// // 枚举定义, 因为GRID_TYPE放在了GridView中, 这里为了保证当前脚本运行, 单独列出\r\n// export enum GRID_TYPE {\r\n\r\n//     GRID_HORIZONTAL,\r\n\r\n//     GRID_VERTICAL\r\n// }\r\n// const { ccclass, property, executeInEditMode } = _decorator;\r\n\r\n// export default class VertexGradient extends Component {\r\n//     @property({ tooltip: '是否反向' })\r\n//     set invert(v) {\r\n//         if (this._bInvert != v) {\r\n//             this._bInvert = v;\r\n//             this.markColorDirty();\r\n//         }\r\n//     }\r\n\r\n//     get invert() {\r\n//         return this._bInvert;\r\n//     }\r\n\r\n//     @property\r\n//     _bInvert: boolean = false;\r\n\r\n//     @property({ type: Enum(GRID_TYPE) })\r\n//     set dir(v) {\r\n//         if (this._dir != v) {\r\n//             this._dir = v;\r\n//             this.markColorDirty();\r\n//         }\r\n//     }\r\n\r\n//     get dir() {\r\n//         return this._dir;\r\n//     }\r\n\r\n//     @property({ type: Enum(GRID_TYPE) })\r\n//     _dir: GRID_TYPE = GRID_TYPE.GRID_VERTICAL;\r\n\r\n//     @property(Color)\r\n//     set downColor(value) {\r\n//         if (!this._downColor.equals(value)) {\r\n//             this._downColor.set(value);\r\n//             this.markColorDirty();\r\n//         }\r\n//     }\r\n//     get downColor() {\r\n//         return this._downColor.clone();\r\n//     }\r\n//     @property(Color)\r\n//     private _downColor: Color = Color.WHITE;\r\n\r\n//     @property(Color)\r\n//     set upColor(value) {\r\n//         if (!this._upColor.equals(value)) {\r\n//             this._upColor.set(value);\r\n//             this.markColorDirty();\r\n//         }\r\n//     }\r\n//     get upColor() {\r\n//         return this._upColor.clone();\r\n//     }\r\n//     @property(Color)\r\n//     private _upColor: Color = Color.WHITE;\r\n\r\n//     onLoad() {\r\n//         let render = this.getComponent(RenderComponent);\r\n//         render[\"_updateColor\"] = this._updateColor.bind(this);\r\n//         this.markColorDirty();\r\n//     }\r\n\r\n//     markColorDirty() {\r\n//         let render = this.getComponent(RenderComponent);\r\n//         render.node[\"_renderFlag\"] |= (cc as any).RenderFlow.FLAG_COLOR | (cc as any).RenderFlow.FLAG_OPACITY;\r\n//     }\r\n\r\n//     _updateColor() {\r\n//         let colors = [];\r\n//         switch (this.dir) {\r\n//             case GRID_TYPE.GRID_VERTICAL:\r\n//                 {\r\n//                     colors = [this.upColor, this.upColor, this.downColor, this.downColor];\r\n//                 }\r\n//                 break;\r\n\r\n//             case GRID_TYPE.GRID_HORIZONTAL:\r\n//                 {\r\n//                     colors = [this.downColor, this.upColor, this.downColor, this.upColor];\r\n//                 }\r\n//                 break;\r\n//         }\r\n\r\n//         if (this.invert) {\r\n//             colors = colors.reverse();\r\n//         }\r\n\r\n//         const cmp = this.getComponent(RenderComponent);\r\n//         if (!cmp) return;\r\n//         const _assembler = cmp['_assembler'];\r\n//         if (!(_assembler instanceof cc['Assembler2D'])) return;\r\n//         const uintVerts = _assembler._renderData.uintVDatas[0];\r\n//         if (!uintVerts) return;\r\n//         const color = this.node.getComponent(Sprite).color;\r\n//         const floatsPerVert = _assembler.floatsPerVert;\r\n//         const colorOffset = _assembler.colorOffset;\r\n//         let count = 0;\r\n\r\n//         for (let i = colorOffset, l = uintVerts.length; i < l; i += floatsPerVert) {\r\n//             uintVerts[i] = (colors[count++] || color)['_val'];\r\n//         }\r\n//         cmp.setVertsDirty();\r\n//     }\r\n// }\r\n\r\n"]}
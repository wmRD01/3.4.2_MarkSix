{"version":3,"sources":["file:///C:/CocosProject/3.4.2_MarkSix/node_modules/crypto-es/lib/mode-cfb.js"],"names":["CFB","generateKeystreamAndEncrypt","words","offset","blockSize","cipher","_words","keystream","iv","_iv","slice","undefined","_prevBlock","encryptBlock","i","BlockCipherMode","Encryptor","processBlock","_cipher","call","Decryptor","thisBlock"],"mappings":";;;uBA+BaA,G;;AA3Bb,WAASC,2BAAT,CAAqCC,KAArC,EAA4CC,MAA5C,EAAoDC,SAApD,EAA+DC,MAA/D,EAAuE;AACrE,QAAMC,MAAM,GAAGJ,KAAf;AACA,QAAIK,SAAJ,CAFqE,CAIrE;;AACA,QAAMC,EAAE,GAAG,KAAKC,GAAhB,CALqE,CAOrE;;AACA,QAAID,EAAJ,EAAQ;AACND,MAAAA,SAAS,GAAGC,EAAE,CAACE,KAAH,CAAS,CAAT,CAAZ,CADM,CAGN;;AACA,WAAKD,GAAL,GAAWE,SAAX;AACD,KALD,MAKO;AACLJ,MAAAA,SAAS,GAAG,KAAKK,UAAjB;AACD;;AACDP,IAAAA,MAAM,CAACQ,YAAP,CAAoBN,SAApB,EAA+B,CAA/B,EAhBqE,CAkBrE;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,SAApB,EAA+BU,CAAC,IAAI,CAApC,EAAuC;AACrCR,MAAAA,MAAM,CAACH,MAAM,GAAGW,CAAV,CAAN,IAAsBP,SAAS,CAACO,CAAD,CAA/B;AACD;AACF;AAED;AACA;AACA;;;;;;;AA7BEC,MAAAA,e,gBAAAA,e;;;qBA8BWf,G,GAAN,MAAMA,GAAN,SAAkBe,eAAlB,CAAkC,E;;AAEzCf,MAAAA,GAAG,CAACgB,SAAJ,GAAgB,cAAchB,GAAd,CAAkB;AAChCiB,QAAAA,YAAY,CAACf,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,cAAME,MAAM,GAAG,KAAKa,OAApB;AACA,cAAM;AAAEd,YAAAA;AAAF,cAAgBC,MAAtB;AAEAJ,UAAAA,2BAA2B,CAACkB,IAA5B,CAAiC,IAAjC,EAAuCjB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAL0B,CAO1B;;AACA,eAAKO,UAAL,GAAkBV,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AACD;;AAV+B,OAAlC;AAYAJ,MAAAA,GAAG,CAACoB,SAAJ,GAAgB,cAAcpB,GAAd,CAAkB;AAChCiB,QAAAA,YAAY,CAACf,KAAD,EAAQC,MAAR,EAAgB;AAC1B;AACA,cAAME,MAAM,GAAG,KAAKa,OAApB;AACA,cAAM;AAAEd,YAAAA;AAAF,cAAgBC,MAAtB,CAH0B,CAK1B;;AACA,cAAMgB,SAAS,GAAGnB,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AAEAH,UAAAA,2BAA2B,CAACkB,IAA5B,CAAiC,IAAjC,EAAuCjB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAR0B,CAU1B;;AACA,eAAKO,UAAL,GAAkBS,SAAlB;AACD;;AAb+B,OAAlC","sourcesContent":["import {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Generate keystream\n  if (iv) {\n    keystream = iv.slice(0);\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n  cipher.encryptBlock(keystream, 0);\n\n  // Encrypt\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n\n/**\n * Cipher Feedback block mode.\n */\nexport class CFB extends BlockCipherMode {\n}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n"]}